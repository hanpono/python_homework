# 0. У учителя есть шоколадка размером n x m кусочков. Учитель решил, распределит шоколадку справедливо, и каждому ученику будет дано одинаковое количество кусочков, а оставшееся останется у него.
# Может произойти, что от шоколадки ничего не останется, но ученики очень добросовестны, поэтому, если у учителя не будет кусочка, а у учеников будет больше одного, тогда каждый отдаст по одному своему кусочку,
# но если у учеников есть только один кусочек, тогда учителю ничего не дадут. Если шоколадка слишком маленькая для деления между всеми учениками, то деления не будет и всё останется у учителя.
# Зная количество учеников s, размер шоколада n, m, распечатайте, сколько кусочков получит каждый ученик и учитель. Данные приведены в следующем порядке: n, m, s.
# Вывод должен быть в виде: У учителя X плиток, у ученика Y плиток.
#
n = int(input('Ввести длину шоколадки: '))
m = int(input('Ввести ширину шоколадки: '))
s = int(input('Ввести количество учеников: '))

area = m * n
pieces = area // s
teacher = area % s

if teacher == 0 and pieces > 1:
    teacher = s
    pieces -= 1

print(f'У учителя {teacher} плиток, у ученика {pieces} плиток')

# 1. Квадрат трёхзначного числа оканчивается тремя цифрами равными этому числу. Найти и вывести все числа в порядке
# убывания.

print(*[i for i in range(999, 99, -1) if int(str(i ** 2)[-3:]) == i])

# 2. Реализовать функцию repl, которая принимает на вход строку и набор заранее неизвестных параметров.
# Результатом функции является строка, в которой слова совпадающие с именами параметров заменены
# на значения параметров. Пример: repl('replace my val abc', my='s1', abc='fff') -> 'replace s1 val fff'
def repl(stroka, **mydict):
    for key, value in mydict.items():
        stroka = stroka.replace(key, value)
    return stroka

print(repl('replace my val abc', my='s1', abc='fff'))


# 3. Есть двумерный список натуральных чисел. Написать функцию, которая проверяет уникальность элементов в этом списке.
# Если в списке только уникальные элементы - возвратить True, иначе - False.

# Примеры:
lst_1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
lst_2 = [[9, 2, 3], [4, 5, 6], [7, 8, 9]]
lst_3 = [[1, 2, 1], [4, 5, 6], [7, 8, 9]]

def unique_func(lst):
    # s = [elem for row in lst for elem in row]
    s =  sum(lst, [])
    return len(set(s)) == len(s)


print(unique_func(lst_1))
print(unique_func(lst_2))
print(unique_func(lst_3))
